<% provide(:title, accessed_page_name) %>

<article>

    <section>
        <h2><%= accessed_page_name %></h2>
        <%= image_tag("SknServices-Strategy.png", alt: "Main Path", class: "huge-image") %>
    </section>

    <section>
        <div class="panel panel-info">
            <div class="panel-heading" role="tab" id="headingGuidance">
                <h4 class="panel-title">
                    <a class="collapsed" role="button" data-toggle="collapse" href="#guidance" aria-expanded="false" aria-controls="headingGuidance">
                        Design Guidance: Commentary
                    </a>
                </h4>
            </div>
            <div id="guidance" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingGuidance">
                <div class="panel-body">
                    <p class="lead">DO NOT FOLLOW THE RAILS WAY.</p>
                    <p>The MVC model is a classic and used with success, as is, for many applications.  However, there are many maintenance, scaling, and growth issues when the codeset exceeds a certain size or features set mix.
                    Understanding these growth issues, it is recommended that you apply a more traditional <strong>Domain Driven Design(DDD)</strong> or <strong>Object Oriented(OO)</strong> approach to building web applications, with Rails isolated as a Web Interface as much as possible.</p>
                    <p>This would involve treating all of Rails as a Web Interface or adapter, and isolating our application business logic from it.  Calling on Rails only when absolutely needed to exchange
                        results with the user.</p>
                    <p>However, this is not another Web Framework! It is a thought provoking alternative to the Rails Way. An alternative that still builds applications using the full capabilities of Rails, while keeping your business logic components separate from Rails.
                     This avoids the negative impact of Rails release changes, and enables your ability to easily add or change features.</p>
                    <p class="lead">This application source, and implementation, serves as a model for how web applications can be engineered without sacrificing longevity or major reworks.</p>
                </div>
            </div>
            <p>Rails is a Great Web Framework.  Your application can derive great benefit from Rails when engineered (Designed) to co-exist with Rails.</p>
        </div>
		<div class="panel panel-info">
	        <div class="panel-heading" role="tab" id="headingOurWay">
	            <h4 class="panel-title">
	                <a class="collapsed" role="button" data-toggle="collapse" href="#ourWay" aria-expanded="false" aria-controls="headingOurWay">
                        Design Guidance: Our (Services) Way
	                </a>
	            </h4>
	        </div>
	        <div id="ourWay" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingOurWay">
	            <div class="panel-body">                   
			        <p class="lead">We do not add business process logic to Models, controllers, or views! (the classic Rails Way)</p>
              <p>We choose to take one step back from Rails code containers, models - views - controllers, and place our code in different containers more appropriate to our application purpose.  This need not be
                considered a huge departure from the Rails Way, just an alternate approach to building application with Rails.</p>
			        <p>We consider controller methods as entry points into our business logic and those entry points are coded with one-line invocations of our specialty service methods <code class="language-ruby">:service_name.entry_method_name(params)</code>.
			          Where <code class="language-ruby">:service_name</code> is the name of a business process service class associated with the request.
			          This service's method will be/is specially designed to accept input via the requests params and return results using a consistent package of values, which can easily be converted into JSON,
			          or consumed by the view that has been prepared to accept ONE instance variable <code class="language-ruby">@page_controls</code> values container.</p>
                <p>For apps that have some sort of menu-bar or top of page information
			          section.  We up the instance variable count by one, by allowing a <code class="language-ruby">@page_info</code> values container, which would contain all the values needed to populate the top of page information section of
			          that page thru the page partials prepared for it.  In cases where the return code to the controller method is negative, we maintain the <code class="language-ruby">:success, :message</code> keys in the
			          values container (i.e. NestedResult) to carry this failure state.  This allows the controller to redirect to the logical next page based on error, or continue to regular destination
			          on success; message is used for the Flash message when needed.</p>

			          <pre><code class="language-ruby">
class ProfilesController < ApplicationController

  # HTML only response
  def in_action_admin
    @page_controls = content_service.handle_in_action_admin(params)
    flash.notice.now = @page_controls.message if @page_controls.message.present?
  end

  # JSON only response
  def api_content_profile
    @page_controls = content_service.handle_content_api(params)
    render json: @page_controls.to_hash, status: @page_controls.success ? :accepted : :not_found, layout: false, content_type: :json and return
  end

  ...
end
          			</code></pre>

          			<p class="lead">For models we have a similar approach.  Only add what is relevant and required to effectively use or protect the data record.</p>
          			<pre><code class="language-ruby">
ProfileType < ActiveRecord::Base
  has_one :content_profile
  validates_presence_of :name, :description

  def self.option_selects
    self.all.map do |pts|
      [pts.name, pts.id, {data: {description: pts.description}}]
    end
  end
end          				
          			</code></pre>
                    <p>In the case of models this means only short methods to help with form option lists, and the model's own validation methods. Nothing more!</p>
          		</div>
       		</div>
       		<p>If we don't add business logic to the controllers or the models, where does it go?  Answer, in the Services objects which inherit directly from Domain objects.</p>
       		<p>A side benefit of not adding business logic in controllers and models is: <strong><em>If there is no code there, then you don't have to test them!</em></strong>.
          Additionally, if you must test a controller; mocking a single method call, and mocking the @page_controls makes controller testing simpler.</p>
     	</div>

        <div class="panel panel-info">
            <div class="panel-heading" role="tab" id="headingdomains">
                <h4 class="panel-title">
                    <a class="collapsed" role="button" data-toggle="collapse" href="#domains" aria-expanded="false" aria-controls="headingdomains">
                        Design Guidance: Domain and Services Model
                    </a>
                </h4>
            </div>
            <div id="domains" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingdomains">
                <div class="panel-body">
                  <%= image_tag("SknService-ControllerFlow.png", alt: "Flow Path", class: "huge-image") %>

                  <p class="lead">Using object-oriented design methodologies, we develop a domain model for our application, and encapsulate those objectives in a Domain class.</p>
                    <p>To delivery the value contained in a <strong>Domain class</strong> we wrap them in a <strong>Services class</strong>.  Which acts as an adapter to bring that value to the user.  This typically means
                       developing an html page with views and controllers to present the informational results to the user.  However, since we only delivery a package of data values to the controller interface
                       method, it is possible to serve those data values as JSON to a browser based application, like BackBone, or to a wide range of endpoints; even a PDF generator.</p>
                    <p>The core of our Application is defined in an object-oriented fashion and protected or isolated from the delivery frameworks(s) used to delivery its value to the user.
                       When changes and enhancements to the business logic are needed, we can make those changes without great concern or constraints being imposed by the delivery mechanism.  This also facilitates
                       easier upgrades of the delivery frameworks; since we have reduced the number of touch points between our application the Rails.</p>
                    <p>Services inherit directly from Domains to further shield our application from the external frameworks; this is easy to see when considering the controller.  Models on the other hand
                       need to be wrapped by Domain methods to prevent their inline introduction or leakage into the Domains.  I've chosen to go one step further and dedicate a <code class="language-ruby">&lt;context&gt;Provider</code>
                       class that wraps all the ActiveRecord IO calls, expecting it to be called by either Domain methods or Services methods.  I have considered using a Repository strategy to add more isolation and to facilitate testing.
                       For now the specialty domain level IO class provides enough isolation.  Ideally we should be able to write RSpec tests for the service/domain classes without invoking the Rails environment, or at least with fewer dependencies.</p>
                    <p>If service objects are focused on transforming domain results to external interfaces, and strategy.domains themselves are focused on the core business logic of a single process.  Then yes, there will
                       be many or several strategy.domains classes, one to support each business process.  However, a domain class need not do all the heavy lifting, its single-responsibility is producing a contextually valid result
                       from the triggering event or input.</p>
                    <p>Domains produce those results best by invoking secondary task oriented objects to complete elements of the overall process, positioning strategy.domains to be the orchestrator or main-line
                       for the business process they are assigned.  Task oriented objects must adhere to the single-responsibility guideline to maintain their value to the overall system's design.  Again enhancing
                       our ability to test off-line from Rails, and making the code more portable with greater reuse opportunities.  A task object would completely handle a task step or elements of the logical process flow
                       domain objects are responsible for.  <em>use the force!</em></p>
                </div>
              <pre><code class="language-ruby">
class ServiceRegistry < ::Registry::RegistryBase


  ##
  # Application Services used in Controller methods
  ##

  def access_service
    @sf_access_service ||= ::AccessService.new({registry: self})
    yield @sf_access_service if block_given?
    @sf_access_service
  end

  ...
end
                </code></pre>
              <pre><code class="language-ruby">
class ContentService < ::ContentProfileDomain


  # Controller Entry Point
  def handle_in_action_admin(params={})
    SknUtils::NestedResult.new({
                                   success: true,
                                   message: "",
                                   page_users: get_page_users(PROFILE_CONTEXT)
                               })
  rescue Exception => e
    Rails.logger.error "#{self.class.name}.#{__method__}() Klass: #{e.class.name}, Cause: #{e.message} #{e.backtrace[0..4]}"
    SknUtils::NestedResult.new({
                                   success: false,
                                   message: e.message,
                                   page_users: []
                               })
  end

  ...
end
              </code></pre>

              <pre><code class="language-ruby">
 class ContentProfileDomain </code></pre>

            </div>
            <p class="lead">Admittedly, this demonstration has not reached that level of <em>Nirvana</em> yet, but it is the design objective! Refactoring now has a clear target (i.e plan).</p>
        </div>

        <div class="panel panel-info">
        <div class="panel-heading" role="tab" id="headingintents">
            <h4 class="panel-title">
                <a class="collapsed" role="button" data-toggle="collapse" href="#intents" aria-expanded="false" aria-controls="headingintents">
                    Design Guidance: This Application's Value Domain and Intent
                </a>
            </h4>
            </div>
            <div id="intents" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingintents">
                <div class="panel-body">
                    <p class="lead">Intended to be a feasible example demonstrating Authentication, Authorization, and Content Access Control.</p>
                    <dl class="dl-horizontal">
                        <dt>Primary Use Case</dt>
                        <dd>
                            <p>Allow users to download a collection of file based content.  The content is protected
                            by access and content controls, ensuring only users authorized for that type of content have access.</p>
                        </dd>
                        <dt>Administer Profiles</dt>
                            <dd>
                                <p>Represent what content access we desire for each user in a standardized way, via the ContentProfile.
                                   Provide ancillary and administrative processes to register and maintain users for the application.</p>
                            </dd>
                        <dt>Execute AccessProfile</dt>
                            <dd>
                                <p>Apply the pre-defined AccessProfile control to all navigation and clickable actions of the application.</p>
                            </dd>
                        <dt>Execute ContentProfile</dt>
                            <dd>
                                <p>Apply the pre-defined ContentProfile controls against down-loadable assets requests from a user.</p>
                            </dd>
                    </dl>
                </div>
            </div>
            <p>Now for the architectural component details. i.e how these design principals were applied to meet the business model objective?</p>
        </div>

        <div class="panel panel-info">
            <div class="panel-heading" role="tab" id="headingUp">
                <h4 class="panel-title">
                    <a class="collapsed" role="button" data-toggle="collapse" href="#UserProfileService" aria-expanded="false" aria-controls="headingUp">
                      [Services Strategy] UserProfile
                    </a>
                </h4>
            </div>
            <div id="UserProfileService" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingUp">
                <div class="panel-body">
                    <h5>UserProfile</h5>
                    <dl class="dl-horizontal">
                        <dt>Instantiate</dt>
                            <dd>
                                <p>By Warden at user login, via Class methods.</p>
                                <p>Requires a User object to instantiate itself, and that object must have a unique Id.</p>
                                <p>During initialization the user's roles are rendered from those assigned via group roles.</p>
                            </dd>
                        <dt>Inheritance</dt>
                            <dd><p>Secure::UserProfile is a base class with direct access to the memory-based Object Storage Interface Module <code class="language-ruby">Registry::ObjectStorageService</code>, capable of keeping references to memory
                                objects across the users request/response cycle; much like the session does and for the same reasons. i.e some objects are expensive to create and may benefit from session-like
                                retention until there usage is complete.</p>
                        <dt>Provides</dt>
                            <dd>
                                <p>Secure::UserProfile provides the User Context for all application processes.</p>
                                <p>Isolates external authentication sources and methods from our internal details. External systems need only
                                    authenticate a user and pass along a persistent and unique id.  User permission or roles can be included in
                                    this external bundle, or we can do an internal mapping of that external user.  This system has its own internal
                                    User table which contains the persistent Id, individual and group roles.</p>
                                <p>Static class methods are provided to allow Warden to:<br/>
                                    <dl>
                                        <dt><code class="language-ruby">:find_and_authenticate_user(uname, upass)</code></dt>
                                            <dd>Locate a user with these credentials in whatever user store is available</dd>
                                        <dt><code class="language-ruby">:fetch_remembered_user(token)</code></dt>
                                            <dd>Locate a user using their remember token</dd>
                                        <dt><code class="language-ruby">:fetch_cached_user(token)</code></dt>
                                            <dd>Locate an existing user exclusively from the inMemory storage facility.</dd>
                                        <dt><code class="language-ruby">:logout(token)</code></dt>
                                            <dd>Log out the user and remove them from the inMemory storage, clear their remember_token and session.</dd>
                                        <dt><code class="language-ruby">:last_login_time_expired?(user_object)</code></dt>
                                            <dd>Update the last time user access the system and if expired, revalidate their credentials.</dd>
                                        <dt><code class="language-ruby">:authenticate?(unencrypted_password)</code></dt>
                                            <dd>Bcryts Authenticate returns self, we need to override that return value to return self instead</dd>
                                        <dt><code class="language-ruby">:enable_authentication_controls</code></dt>
                                            <dd>After successful login, this method saves the user object into our inMemory storage for later session level retrieval. Also update :last_access.</dd>
                                        <dt><code class="language-ruby">:disable_authentication_controls</code></dt>
                                            <dd>Remove the user object reference from inMemory storage, updates :last_access.</dd>
                                    </dl>
                                </p>
                                <p>Static class methods are provided to facilitate content profile, and testing service to:<br/>
                                    <dl>
                                        <dt><code class="language-ruby">:page_users(context)</code></dt>
                                            <dd>Retrieve the list of all users without logging them in.  For use with offline operations.</dd>
                                        <dt><code class="language-ruby">:page_user(uname, context)</code></dt>
                                            <dd>Retrieves a single user object without logging it in, for offline use.</dd>
                                    </dl>
                                </p>
                                <p>Instance methods are provided to allow AccessRegistry access control application wide:<br/>
                                <ul class="">
                                    <li><code class="language-ruby">:has_access?(resource_uri,options)</code></li>
                                    <li><code class="language-ruby">:has_create?(resource_uri,options)</code></li>
                                    <li><code class="language-ruby">:has_read?(resource_uri,options)</code></li>
                                    <li><code class="language-ruby">:has_update?(resource_uri,options)</code></li>
                                    <li><code class="language-ruby">:has_delete?(resource_uri,options)</code></li>
                                </ul>
                                </p>
                                <p>Instance methods support ApplicationHelper methods for use in view and controller actions:<br/>
                                <ul class="">
                                    <li><code class="language-ruby">:current_user_has_access?(uri, options)</code></li>
                                    <li><code class="language-ruby">:current_user_has_read?(uri, options)</code></li>
                                    <li><code class="language-ruby">:current_user_has_create?(uri, options)</code></li>
                                    <li><code class="language-ruby">:current_user_has_update?(uri, options)</code></li>
                                    <li><code class="language-ruby">:current_user_has_delete?(uri, options)</code></li>
                                </ul>
                                </p>
                                <p>Designed to be the User's proxy to the whole system.  Working in concert with Authentication and
                                    Authorization components it enables delivery of secure content with the availability of different authentication schemes.</p>
                            </dd>
                    </dl>
                </div>
            </div>
            <p>The User's Context</p>
        </div>

        <div class="panel panel-info">
            <div class="panel-heading" role="tab" id="headingTwo">
                <h4 class="panel-title">
                    <a class="collapsed" role="button" data-toggle="collapse" href="#ServiceRegistry" aria-expanded="false" aria-controls="collapseTwo">
                      [Services Strategy] ServiceRegistry
                    </a>
                </h4>
            </div>
            <div id="ServiceRegistry" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingTwo">
                <div class="panel-body">
                  <%= image_tag("SknService-RegistryMethod.png", alt: "Flow Path", class: "huge-image") %>
                    <h4>ServiceRegistry</h4>
                    <dl class="dl-horizontal">
                        <dt>Instantiate</dt>
                        <dd>
                            <p>ServiceRegistry is instantiated by the top level Application Controller using a <code class="language-ruby">:before_action</code> callback to a private method
                                called <code class="language-ruby">:establish_domain_services</code>.  There is also a twin to this callback referred to as <code class="language-ruby">:manage_domain_services</code>,
                                called by the <code class="language-ruby">:after_action</code> callback.</p>
                            <p><code class="language-ruby">:establish_domain_services</code> and <code class="language-ruby">:manage_domain_services</code> work to recover assets from the request session, and to save keys
                                to those assets into the session just before the controller exits back to the browser.  The ServiceRegistry is lightwieght and would derive no real benefit from being
                                serialized into a session.  So it is simply created anew with each request/response cycle.</p>
                            <p>The ServiceRegistry itself is instantiated as <code class="language-ruby">@service_registry</code> in the top level ApplicationController, behind a memotizing method <code class="language-ruby">service_registry</code>.
                                To instantiate a processService use: <code class="language-ruby">process_service.service_method_name(params)</code>.</p>
                            <p>The intended use of the <code class="language-ruby">service_registry</code> is to provide lazy instantiation and memotization of all strategy components classes in the application. And to additionally
                                provide them critical facilites, like <code class="language-ruby">:current_user</code>, and act as an isolation gateway to the application controller.</p>
                            <p>Inside a processService, like ContentService or ProfileProviders, reference the service_registry as <code class="language-ruby">:registry</code> or <code class="language-ruby">:service</code>, as in: <code class="language-ruby">registry.content_service.some_method</code> .</p>
                        </dd>
                        <dt>Inheritance</dt>
                        <dd><p>ServiceRegistry, inherits from <code class="language-ruby">::Registry::RegistryBase</code> which yields a memory-based Object Storage Interface Module <code class="language-ruby">Registry::ObjectStorageService</code>, capable of keeping references to memory
                            object across the users request/response cycle; much like the session does and for the same reasons. i.e some objects are expensive to create and may benefit from session-like
                            retention until there usage is complete.</p>
                        <dt>Provides</dt>
                        <dd>
                            <p>ServiceRegistry provides Services with the <code class="language-ruby">:current_user</code>, <code class="language-ruby">:registry</code> reference, and a <code class="language-ruby">:method_missing</code> feature capable of
                                directing :not_found method calls to the controller to be serviced if possible.</p>
                            <p>Services should truly limit their demands of the controller object to zero if possible, and have the service_registry devise a solution to their requirements.  The most often
                                experienced demand for the controller is when a service needs to resolve a named route or render a template partial to embed in a json response.</p>
                            <p>Let's not recreate the application controller, for those types of requirements use the controller, just wrap those patterns in a method defined in the service_registry or a
                                controller helper/presenter.  This way it can be easily mocked out later for testing.  In fact, I do use a <code class="language-ruby">:page_actions</code> view helper located in the
                                ApplicationHelper module, to handle rendering and route resolutions from a hashed set of control data from a service.  Basically, outsourcing to the ActionView those things it does best; and totally removing the need for a controller object in the majority of strategy.services and strategy.domains.</p>
                            <p>Engineering objectives shall include, avoidance of the controller in all strategy.services, strategy.domains, and specialty business strategy.services classes.  It is possible and practical, your RSpec tests will demonstrate it later.</p>
                         </dd>
                        <dt>ObjectStorageService API</dt>
                        <dd>
                                    <div class="well-sm">
                                    <p># Saves object to inMemory ObjectStore<br/>
                                       # Returns storage key, needed to retrieve<br/>
                                        <code class="language-ruby">:save_new_object(obj)</code></p>
                                    </div>
                                    <div class="well-sm">
                                     <p># Updates existing container with new object reference<br/>
                                        # returns object<br/>
                                        <code class="language-ruby">:set_existing_object(key, obj)</code></p>
                                    </div>
                                    <div class="well-sm">
                                        <p># Retrieves object from InMemory Storage<br/>
                                        # returns object<br/>
                                        <code class="language-ruby">:get_existing_object(key)</code></p>
                                    </div>
                                    <div class="well-sm">
                                        <p># Releases object from InMemory Storage<br/>
                                        # returns object, if present<br/>
                                        <code class="language-ruby">:remove_existing_object(key)</code></p>
                                    </div>
                        </dd>
                        <dt>Session API</dt>
                        <dd>
                            <div class="well-sm">
                                <p><code class="language-ruby">:get_session_params(key)</code><br/>
                                <code class="language-ruby">:set_session_params(key, value)</code></p>
                            </div>
                        </dd>
                        <dt>Named Route Helpers</dt>
                        <dd>
                            <div class="well-sm">
                              <p>
                                Converts named routes to string<br/>
                                  Basic: <code class="language-ruby">[:named_route_path, {options}, '?query_string']</code><br>
                                  Advanced: <code class="language-ruby">{engine: :demo, path: :demo_profiles_path, options: {id:111304},query:'?query_string'}</code><br/>
                                <br/>
                                Example: <code class="language-ruby">registry.page_action_paths(paths)</code></p>
                            </div>
                        </dd>
                    </dl>
                    <p>All Components, like ContentService, AccessService, DBProfileProvider, XMLProfileProvider, FileSystemAdapter, and InlineValuesAdapter
                      are instantiated via the service_registry facilities.  And primary utility objects can also be supported via the service registry.</p>
                </div>
            </div>
            <p>Primary Component of this Services Strategy. Providing access to all application strategy.services!</p>
        </div>

        <div class="panel panel-info">
            <div class="panel-heading" role="tab" id="headingTwo">
                <h4 class="panel-title">
                    <a class="collapsed" role="button" data-toggle="collapse" href="#ContentService" aria-expanded="false" aria-controls="collapseTwo">
                      [Services Strategy] processServices
                    </a>
                </h4>
            </div>
            <div id="ContentService" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingTwo">
                <div class="panel-body">
                    <h5>processServices</h5>
                    <dl class="dl-horizontal">
                        <dt>Instantiate</dt>
                        <dd>
                            <p>ServiceRegistry provides instantiation strategy.services to any requester in the request/response cycle.</p>
                            <p>The intended use of processServices object methods is to handle all operations for a controller entry point(url), and return a single information bundle <code class="language-ruby">@page_controls</code>, based
                                on the <code class="language-ruby">SknUtils::NestedResult</code> group of result value containers.</p>
                        </dd>
                        <dt>Inheritance</dt>
                        <dd><p>processServices inherit business logic from the <code class="language-ruby">processDomain</code> class.  The processDomain class inherits from the <code class="language-ruby">::Registry::DomainsBase</code>,
                            which yields common initialization strategy.services like the current_user() and access to the service_registry for interaction with the controller helpers if needed.  In particular, the <code class="language-ruby">service_registry</code> includes
                            object storage strategy.services and session storage strategy.services through its inheritance chain.</p>
                        <dt>Provides</dt>
                        <dd><p>processServices present customized business logic and standard information packaging for the application entry points assigned to  it.  Where ever used you can be assured of a valid response encoded
                            in a <code class="language-ruby">@page_controls</code> value container, and all exceptions are trapped by this top level method.   PageControl value containers are required to include
                            <code class="language-ruby">success: true|false, message: error_message|success_message|empty, and payload: [domainData]</code> values at a minimum.</p>
                            <p>JSON Api or regular HTML methods are hosted by this service.</p>
                        </dd>
                    </dl>
                </div>
            </div>
            <p>Instantiated by: <code class="language-ruby">service_registry()</code></p>
        </div>

        <div class="panel panel-info">
            <div class="panel-heading" role="tab" id="headingThree">
                <h4 class="panel-title">
                    <a class="collapsed" role="button" data-toggle="collapse" href="#DomainServices" aria-expanded="false" aria-controls="collapseThree">
                      [Services Strategy] processDomains
                    </a>
                </h4>
            </div>
            <div id="DomainServices" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingThree">
                <div class="panel-body">
                    <h5>processDomains</h5>
                    <dl class="dl-horizontal">
                        <dt>Instantiate</dt>
                        <dd>
                            <p>processDomains are not instantiated directly, they are inherited by higher level and more specialized service classes.</p>
                            <p>The intended use of strategy.domains class methods is to offer a business logic control of a
                              single business process. It is the starting point for all business process
                              strategy.services.</p>
                        </dd>
                        <dt>Inheritance</dt>
                        <dd><p>processDomains inherit directly from the <code class="language-ruby">::Registry::DomainsBase</code> class, and yields business logic methods to higher level service objects.
                            Services take the results of one or more of these <em>business logic complete</em> methods and package them for external exchange in the controller response.</p>
                        <dt>Provides</dt>
                        <dd><p>processDomains have logical access to the service registry and all other peer strategy.services the registry manages.  Typically you would find two to three levels of methods in a Domain class.</p>
                            <dl>
                                <dt>Level One</dt>
                                <dd>Top level business interface.  Methods at this level take responsibility for doing the whole process step; process a order or payment, would be an example of this.</dd>
                                <dt>Level Two</dt>
                                <dd>The notion of the whole process setp, is likely to have component tasks involved.  At this level methods are expected to perform one whole task.
                                    For this single-responsibility reason, we recommend creating dedicated objects to handle these component parts.</dd>
                                <dt>level Three</dt>
                                <dd>Is rarely needed, but if so would handle very narrow objectives; like I/O or RESTFul routines.</dd>
                            </dl>
                            <p>This is the best place to exploit object-oriented design principles.  To that end, we include design components to meet the most frequent use cases; namely: <code class="language-ruby">domainProviders</code>, and <code class="language-ruby">taskProcessor</code>.</p>
                        </dd>
                    </dl>
                </div>
                <p>The Business Process Interface is here.</p>
            </div>
            <p>Inherited by: <code class="language-ruby">ContentService, ...</code></p>
        </div>

      <div class="panel panel-info">
        <div class="panel-heading" role="tab" id="headingOne">
          <h4 class="panel-title">
            <a role="button" data-toggle="collapse" href="#ProfileDataServices" aria-expanded="true" aria-controls="collapseOne">
              [Services Strategy] domainProviders
            </a>
          </h4>
        </div>
        <div id="ProfileDataServices" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingOne">
          <div class="panel-body">
            <h5>domainProviders</h5>
            <dl class="dl-horizontal">
              <dt>Instantiate</dt>
              <dd>
                <p>ServiceRegistry provides instantiation strategy.services to any requester in the request/response cycle.</p>
                <p>The intended use of a domainProvider object, is to handle all business object persistence related operations for domain context data. It should not interact directly any object aside from the domain object that calls it, and the Database Interface.</p>
              </dd>
              <dt>Inheritance</dt>
              <dd><p>domainProviders inherit common instantiation service from the <code class="language-ruby">Providers::ProvidersBase</code> class.  The Providers::ProvidersBase yields common initialization strategy.services, and object storage strategy.services.</p>
              </dd>
              <dt>Provides</dt>
              <dd><p>DBProfileProvider provides contextual data access for content profile data objects with standard data packaging for internal processes.</p>
                  <p>domainProviders by design should handle contextual IO for all or a subset of business objects. Returning results as a attribute hash or ValueBean, never returning the underlying ActiveModel object.</p>
              </dd>
            </dl>
          </div>
          <p>Currently there are two implementations of this component: XMLProfileProvider and DBProfileProvider classes. </p>
        </div>
        <p>Instantiated by: <code class="language-ruby">service_registry()</code></p>
      </div>

      <div class="panel panel-info">
        <div class="panel-heading" role="tab" id="headingThree">
          <h4 class="panel-title">
            <a class="collapsed" role="button" data-toggle="collapse" href="#ProfileBuilder" aria-expanded="false" aria-controls="collapseThree">
              [Services Strategy] Processors
            </a>
          </h4>
        </div>
        <div id="ProfileBuilder" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingThree">
          <div class="panel-body">
            <h5>Processor</h5>
            <dl class="dl-horizontal">
              <dt>Instantiate</dt>
              <dd>
                <p>ServiceRegistry provides instantiation strategy.services to any requester in the request/response cycle.</p>
                <p>The intended use of a Processor is to handle specialized tasks which may include external IO of some sort, for Domains.</p>
              </dd>
              <dt>Inheritance</dt>
              <dd><p>A task processor inherits directly from the <code class="language-ruby">Processors::ProcessorBase</code> class.  The ProcessorBase yields common initialization strategy.services, and access to the service registry.</p>
              </dd>
              <dt>Provides</dt>
              <dd><p>FileSystemAdapter provides logical access to content storage facilities.</p>
                <p>taskProcessor by design are expected to handle a complete and single task step of a larger process flow, and have no dependencies.  However to complete their assigned task they may engage other task processors, strategy.services, and providers; thus they do benefit from access to the </p>
              </dd>
            </dl>
          </div>
          <p>Currently there are two implementations of this component: FileSystemAdapter and InlineValueAdapter classes. </p>
        </div>
        <p>Instantiated by: <code class="language-ruby">service_registry()</code>.  However, they are capable of operating independently of the </p>
      </div>

        <div class="panel panel-info">
            <div class="panel-heading" role="tab" id="headingTwo">
                <h4 class="panel-title">
                    <a class="collapsed" role="button" data-toggle="collapse" href="#SknUtils" aria-expanded="false" aria-controls="collapseTwo">
                      [Services Strategy] NestedResult or DottedHash Value Containers
                    </a>
                </h4>
            </div>
            <div id="SknUtils" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingTwo">
                <div class="panel-body">
                    <p>The <strong>skn_utils.gem</strong> contains dynamic base classes inherited to create local value containers or plain old ruby objects (PORO).</p>
                    <p>Initialized with a Hash of key value pairs: <code class="language-ruby">res = SknUtils::NestedResult.new({one: 1, two: [{one: 'one', two: 'two'}]})</code>  The keys become method names that return the associated values.  This
                    transformation of the hash continues, during its initialization, to follow nested hashes, arrays of hashes, and arrays of array of hashes.</p>
                    <p>Overall the result of using this gem is an easily used container for transporting or packaging values for use in views, json responses, etc.
                    Accessing the values in a SknUtil::NestedResult can be done using <code class="language-ruby">dot</code> notation, or <code class="language-ruby">hash</code> notation:
                    example: <code class="language-ruby">res.one #=> 1</code>, <code class="language-ruby">res.two.first.two #=> 'two'</code></p>
                    <p>If you need to unwrap the container to convert it to json or just to have the hash back;<br/> <code class="language-ruby">res.to_hash #=> {one: 1, two: [{one: 'one', two: 'two'}]}</code>, gets the job done.</p>
                    <p>There are many more logical features built into the package, read more at <a href="https://github.com/skoona/skn_utils">SknUtils</a>. The is one feature that you should know and use:
                    the present <code class="language-ruby">&lt;keyName&gt;?</code> feature.  Example: <code class="language-ruby">res.two? #=> true,  res.twenty? #=> false</code></p>

                    <dl class="dl-horizontal">
                        <dt>SknUtils::NestedResult</dt>
                          <dd>Used directly to transport values to controller method.</dd>
                    </dl>
                </div>
            </div>
            <p>skn_utils.gem</p>
        </div>

        <div class="panel panel-info">
            <div class="panel-heading" role="tab" id="headingTwo">
                <h4 class="panel-title">
                    <a class="collapsed" role="button" data-toggle="collapse" href="#RailsViews" aria-expanded="false" aria-controls="collapseTwo">
                      [Services Strategy] Rails View Helpers
                    </a>
                </h4>
            </div>
            <div id="RailsViews" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingTwo">
                <div class="panel-body">
                    <p>Rails Views: BootStrap, JQuery DataTables, and SimpleForms are our choice for classic erb page composition and rendering.</p>
                    <h4>View Helpers/Builders</h4>
                    <dl class="dl-horizontal">
                        <dt>PageActionsBuilder</dt>
                        <dd>
                            <p>A Class designed to build page action dropdown menus from an array of hashes contain with keys describing each menu item.</p>
                            <p>It is initiated by an <code class="language-ruby">ApplicationHelper#do_page_actions</code> and assumes it input array is in either <code class="language-ruby">@page_controls.page_actions or .package.page_actions</code>.</p>
                            <p>In your strategy.services routine response you can add a <code class="language-ruby">:page_actions</code> array of params, and this helper will create the classic pulldown or action button for you.</p>
                        </dd>
                        <dt>#page_action_paths</dt>
                        <dd>
                            <p>Located in <code class="language-ruby">ApplicationHelper#page_action_paths</code>, this methods resolves named routes into strings.  You
                            would use this method to resolve named paths for inclusion in json responses, or anywhere else you might need it.</p>
                        </dd>
                    </dl>
                </div>
            </div>
            <p>Describes helpers we created for views.</p>
        </div>
        <div class="panel panel-info">
          <div class="panel-heading" role="tab" id="headingTwo">
              <h4 class="panel-title">
                  <a class="collapsed" role="button" data-toggle="collapse" href="#RSpecTesting" aria-expanded="false" aria-controls="collapseTwo">
                      RSpec Testing
                  </a>
              </h4>
          </div>
          <div id="RSpecTesting" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingTwo">
              <div class="panel-body">
                <p class="lead">RSpec Testing: This Rocks</p>
                <p>The directory <code class="language-ruby">spec/support</code> has a collection of modules and classes to augment testing:</p>
                <ul>
                  <li>
                    <code class="language-ruby">ServiceRegistryMockController</code> A class used to replace the need for a ApplicationController to initialize the ServiceRegistry with. It contains methods that
                    Service or Domain objects might call on the ApplicationController, like: current_user, page_actions, menu_active, etc.  The use of this
                    mock controller has a significant speed increase compared to its alternative <strong>Integration/Controller</strong> tests.
                  </li>
                  <li>
                    <code class="language-ruby">TestUsers</code> contains a collection of methods that will return a testable user_profile object, either fully enabled as the current_user, or simply loaded as an independent record.
                  </li>
                  <li>
                    <code class="language-ruby">TestDataSerializers</code> contains a couple of methods that allow you to save objects to a separate yaml file.  Can be used to capture a <code class="language-ruby">@page_controls</code> object to be used latter as mocking data when testing views.
                  </li>
                </ul>
                <p>Testing Services with RSpec looks like this:</p>
                <pre class="pre-scrollable"><code class="language-ruby">
RSpec.describe ContentService, "Service routines of ContentService." do
  let!(:user) {user_bstester}

  let(:mc) {ServiceRegistryMockController.new(user: user)}
  let(:service_registry)  { ServiceRegistry.new({registry: mc}) }

  let(:service) {service_registry.content_service}

  context "Content Profile Management methods return proper results. " do

    scenario "#handle_content_profile_management prepares a page package of all users" do
      result = service.handle_content_profile_management({})
      expect(result).to be_a(SknUtils::NestedResult)
      expect(result.success).to be true
      expect(result.message).to be_blank
    end

  end

end
                  </code></pre>
              </div>
          </div>
          <P>Finished in 10.76 seconds (files took 3.44 seconds to load) </br>
            223 examples, 0 failures</br>
            Coverage report generated for RSpec to ./coverage/index.html 1275 / 1583 LOC (80.54%) covered.
          </P>
        </div>
        <div class="panel panel-info">
            <div class="panel-heading" role="tab" id="headingTwo">
                <h4 class="panel-title">
                    <a class="collapsed" role="button" data-toggle="collapse" href="#AuthorizationDataModel" aria-expanded="false" aria-controls="collapseTwo">
                        Authorization Data Models
                    </a>
                </h4>
            </div>
            <div id="AuthorizationDataModel" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingTwo">
                <div class="panel-body">
                    <h2>Authorization Data Models</h2>
                    <%= image_tag("SknService-ContentModelOnly.png", alt: "ContentProfile Data Tables", class: "huge-image") %>
                </div>
            </div>
            <p>Authorization Data Models</p>
        </div>
        <div class="panel panel-info">
            <div class="panel-heading" role="tab" id="headingTwo">
                <h4 class="panel-title">
                    <a class="collapsed" role="button" data-toggle="collapse" href="#ApplicationDataModel" aria-expanded="false" aria-controls="collapseTwo">
                        Application Data Model
                    </a>
                </h4>
            </div>
            <div id="ApplicationDataModel" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingTwo">
                <div class="panel-body">
                    <h2>Application Data Model</h2>
                    <%= image_tag("SknService-DataModel.png", alt: "Application Data Model", class: "huge-image") %>
                </div>
            </div>
            <p>Authentication and Authorization Data Models</p>
        </div>
      <div class="panel panel-info">
        <div class="panel-heading" role="tab" id="todo">
          <h4 class="panel-title">
            <a class="collapsed" role="button" data-toggle="collapse" href="#todo-list" aria-expanded="false" aria-controls="collapseTwo">
              To Do List
            </a>
          </h4>
        </div>
        <div id="todo-list" class="panel-collapse collapse" role="tabpanel" aria-labelledby="todo">
          <div class="panel-body">
            <h3>To Do</h3>
            <dl class="dl-horizontal">
              <dt>CommandBase</dt>
                <dd>Processors have two types of implementations based on their intended purpose: Single or Multi Method mode.  Mode is implementation via inheritance; <code class="language-ruby">Processors:ProcessorBase</code> class is for multi-method, <code class="language-ruby">Processors::CommandBase</code> class is for single-method implementation.  Single mode Processors would live outside of the ServiceRegistry umbrella and be invoke directly by Domains when needed; they are desiged to be invoke via: <code class="language-ruby">myCommandProcessor.call(params_hash)</code> </dd>
              <dt>Profile Runtime</dt>
                <dd>A new class to handle runtime requests for user ContentProfiles and authorization queries, rather than bolting these methods on the UserProfile.  While these features are present in the code, I'd like to organize them better.</dd>
              <dt>AccessRegistry</dt>
                <dd>There are a lot of direct calles to the <code class="language-ruby">Secure:AccessRegistry...</code> class which I would like to corral into a AccessRegistry provider or processor.</dd>
              <dt>Clarify</dt>
              <dd>There are three significant and wonderful components in this codeset; as depicted on the homepage.
                <ol>
                  <li>Deep authentication implementation via UserProfile class, backed by Warden and Rack-Attack.</li>
                  <li>Deep authorization coverage of all processes and accessible elements via AccessProfile classes, backed by Warden and ApplicationController.</li>
                  <li>Deep authorization coverage of secured-content based resources via ContentProfile XML or Database classes.</li>
                </ol>
                For which I need to expose as usable features in your app.
              </dd>
            </dl>
          </div>
        </div>
        <p>Todo List: Items I want to spend more time on</p>
      </div>
    </section>

</article>
